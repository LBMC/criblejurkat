\documentclass[a4paper]{article}
\usepackage{pdfpages}
\usepackage[latin9]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{color}
\usepackage{Sweave}
\usepackage{pdfcolmk}
\usepackage{ifthen}
\usepackage{multido}
\usepackage[labelformat = empty]{caption}
\usepackage{fancyhdr}
\usepackage[top=1.2cm, bottom=0.5cm, right=1.3cm, left=1.3cm]{geometry}
\usepackage{lastpage}
\pagestyle{fancy}
\usepackage{rotating}
\usepackage{fancyvrb}
\usepackage{etoolbox}
%\usepackage[final]{pdfpages} 
\usepackage{longtable}
\usepackage{hyperref}
\usepackage{lscape}
\usepackage{float}
\hypersetup{
    colorlinks=true, %set true if you want colored links
    linktoc=all,     %set to all if you want both sections and subsections linked
    linkcolor=blue,  %choose some color if you want links to stand out
}
\makeatletter
\patchcmd{\FV@ListVSpace}{\@topsepadd\topsep}{}{}  %% Reduce space between Sin/output
\makeatother
\fancyhf{}
\rhead{\date\today \hspace{0.2cm}- \thepage/\pageref{LastPage}}
\renewcommand{\footrulewidth}{0pt}
\newcommand{\bslash}{\textbackslash}
\nopagebreak

\begin{document}

\setlength\parindent{0pt}
\def\UseVerbatim{\FV@Command{numbers=left,fontsize=\small}{UseVerbatim}}
\SweaveOpts{tidy = FALSE, keep.source = TRUE, keep.space = FALSE, keep.blank.space = FALSE, keep.comment = TRUE}
\DefineVerbatimEnvironment{Sinput}{Verbatim}{formatcom = {\color[rgb]{0, 0, 0.56}}}
\DefineVerbatimEnvironment{Soutput}{Verbatim}{formatcom = {\color[rgb]{0.56, 0, 0}}}

<< options, echo = FALSE >>=
options(prompt = ">", continue = "...", width = 100)
directory <-tail(strsplit(getwd(), "/")[[1]], 2)
title <- paste("Screening of a chemical library in order to find TAL1 break down inducting factor\n", directory[1], "-", directory[2], sep = "")
@

\title{\Sexpr{title}}
\author{\small Pipeline provided by Claire Burny - Gael Yvert lab - version 20170220}
\maketitle
\tableofcontents
\newpage


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Settings and sourcing useful informations}

When and where we are :
<<dir-and-date, echo = FALSE>>=
date();
R.Version()$version.string;
getwd();
@
 

We source here useful functions and load necessary packages and tools.

<<load-pack-scripts-create-dir>>=
##### Packages #####
options(rgl.useNULL = TRUE) #To uncomment when running on virtual machine
require(xtable)
require(quantmod)
require(flowStats)
require(ggcyto)
require(MASS)
require(gridExtra)
require(gplots)

source("../../src/func/functions.R")

system("mkdir plots")
system("mkdir output_files")
@


<<create-comparisons, echo = F>>=
if (any("compare" == ls()) == F) {
	stop("#### Before running \"screen.Rnw\", you must create an R string variable compare=\"jurkat.GpR-TAL\" to compare effect of drug vs control on these \"compare\" cell lines. Both sets of samples must be DAPI stained. You should also create an alpha for significancy threshold (set to 0.05 by default). Do not forget to make setwd() in virtual machine with path corresponding to your results specific date directory. ####")
} 
if (any("alpha" == ls()) == F) { alpha <- 0.05}
@

<<create-comparisons-print>>=
print(paste("You want to assess drug effect on ", compare, " samples with alpha=", alpha, sep = ""))
@


\subsection*{Data organisation}
The project is organised under a \texttt{project} ("\Sexpr{directory[1]}") parent directory with \texttt{results}/\texttt{data}/\texttt{doc}/\texttt{src} sub-directories, splitted by a \texttt{date} sub-sub-directories (here "\Sexpr{directory[2]}"). .FCS files must be saved in a directory named as the date of the experiment (\texttt{date} column of annotation file, see after). 

<<load-annotation, echo = F>>=
annotation <- read.table("annotation.csv", h = T, sep = ";", stringsAsFactors = F)
annotation$dapi <- as.factor(annotation$dapi)
n.cl <- length(unique(annotation$cell.line))
channels <- read.table("channels.csv", h = T, sep = ";", stringsAsFactors = F)
info <- t(unname(sapply(unique(annotation$cell.line), function(x) {annotation.temp <- annotation[which(annotation$cell.line == x), ]; n <- dim(annotation.temp)[1]; tab.time <- table(annotation.temp$time); c(x, n, table(annotation.temp$dapi)[names(table(annotation.temp$dapi))[1]], table(annotation.temp$drug)[names(table(annotation.temp$drug))[1]], paste(names(tab.time), " UT (", tab.time, ")", sep = "", collapse = " / "))})))
colnames(info) <- c("cell.line", "nb samples", paste("DAPI ", names(table(annotation$dapi))[1], sep = ""), names(table(annotation$drug))[1],"drug time UT (nb samples)")
column.names <- c("01", "02", "03", "04", "05", "06", "07", "08", "09", "10", "11", "12")
row.names <- c("A", "B", "C", "D", "E", "F", "G", "H")
mat.value.template <- matrix(NA, nrow = 8, ncol = 12, dimnames = list(row.names, column.names))
column.template <- matrix(1:96, nrow = 1, dimnames = list(NULL, unlist(sapply(column.names, function(x) paste(row.names, x, sep = ""), simplify = F))))
row.template <- matrix(1:96, nrow = 1, dimnames = list(NULL, unlist(sapply(row.names, function(x) paste(x, column.names, sep = ""), simplify = F))))
@


\subsection*{Annotation}
Each .FCS file the user wants to process must be described as one line of \texttt{annotation.csv} file with the following columns descriptors, exemplified in ():
\begin{itemize}
	\item \texttt{date}: data directory containing the .FCS files as a date ("02202017");
	\item \texttt{file}: .FCS files names ("plate1.0005.fcs");	
	\item \texttt{plate}: plate ID (1);
	\item \texttt{well}: well ID (33);
	\item \texttt{cell.line}: type of sample ("jurkat.neg");
	\item \texttt{dapi}: DAPI labelling or not (TRUE or FALSE);
	\item \texttt{drug}: drug treatment or not ("None", "drug", ...);
	\item \texttt{time}: time of drug administration (if drug treatment, a numeric value in UT, else "None");
	\item \texttt{channels}: comma separated fluorescent markers (if no labelling at all, "None", else "RFP" or "RFP,DAPI" or "GFP,RFP"... depending on the labelling, the order is not important but do not add space);
	\item \texttt{code.well}: position on the plate ("A01", "B01", ...) which must match to the well number of the plate.
\end{itemize}

Above the 1st lines of \texttt{annotation.csv} \textcolor{red}{(';' columns separated)}: \\
<<design, results = tex, echo = F>>=
print(xtable(head(annotation)), hline.after = 0, floating = FALSE, include.rownames = FALSE, include.colnames = TRUE, scalebox = 0.9)
annotation$drug.time <- factor(paste(annotation$drug,".",  annotation$time, "UT", sep = ""))
levels.fact <- levels(annotation$drug.time)
@

  
\subsection*{Channels description}
The user must described the channels which register the fluorescent markers in the cytometer in \texttt{channels.txt} file with the following columns descriptors, exemplified in ():
\begin{itemize}
	\item \texttt{channels}: names of the fluorescent marker ("DAPI" or "RFP" or "GFP")
	\item \texttt{fcs.column}: names of the area channel which register the corresponding fluorescent marker ("V1.A", ...)
\end{itemize}

Above the entire \texttt{channels.txt} (';' columns separated):\\
<<channels, results = tex, echo = F>>=
print(xtable(channels), hline.after = 0, floating = FALSE, include.rownames = FALSE, include.colnames = TRUE)
@


\subsection*{Data description}
Above a summary of data availability for the current project from \texttt{annotation.csv}. \\
<<info, results = tex, echo = F>>=
print(xtable(info), hline.after = 0, floating = FALSE, include.rownames = FALSE, include.colnames = TRUE)
@


%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Data processing}

\begin{itemize}
	\item \textbf{Create an R flowset} object from files provided in the annotation.  
	\item \textbf{Remove saturated events on labelled .A channels} by simple rectangle gates after having pick the min and max values of all size and fluorescence .A channels. For a given size or fluorescent channel, it is required to have .A signal as well as .W for FSC. The size rectangleGate is always applied.
	\item \textbf{Compute the RFP/GFP ratio} according to the right channel. The \textbf{RFP/GFP log2 ratio} is also computed.
	\item \textbf{Gate for debris and then for doublets} in successively SSC.A-FSC.A plane and then FSC.W-FSC.A plane.
\end{itemize}
\textbf{In parallel, fluo channels except but DAPI channel are log10 transformed}.

\subsection*{Output files}
At each successive step involving cells filter, the number of kept cells is registered and eventually written in \texttt{./output\_files/nb\_events.csv} (';' columns separated) with the following columns descriptors:
\begin{itemize}
	\item \texttt{raw}: number of raw cells;
	\item \texttt{unsat}: number of cells after removing saturated cells on labelled .A channels;
	\item \texttt{perc.from.raw}: percentage of kept cells from raw data;
	\item \texttt{first.gating}: number of cells after gate for debris;
	\item \texttt{perc.from.unsat}: percentage of kept cells after the 1st gate;
	\item \texttt{final}: final number of cells after gate for doublets;
	\item \texttt{perc.from.first.gating}: percentage of kept cells after the 2nd gate;
	\item \texttt{perc.from.raw}: percentage of final kept cells from raw data;
\end{itemize}

The final flowframes are saved in \texttt{./output\_files} with \texttt{processed\_} suffix and \texttt{.csv} prefix (';' columns separated).\\

The mean GFP (\texttt{mean.GFP} column) and mean RFP (\texttt{mean.RFP} column) signals as well as the mean GFP/RFP (log2) ratio (\texttt{mean.ratio.RFP.GFP} and \texttt{mean.log2.ratio} columns) are added per sample in the annotation and saved in \texttt{./output\_files/annotation\_ratio\_compare\_...\_alpha....csv} (';' columns separated). p-values associated to comparison of "column-normalized" mean GFP/RFP log2 ratio (saved in \texttt{norm.column.mean.log2.ratio} column) control vs treated samples for cell line \Sexpr{compare} (saved in \texttt{drug.assessment} column) at $\alpha$=\Sexpr{alpha} (saved in \texttt{alpha} column) level are saved in \texttt{pvalue} column. A Shapiro test is performed to assess the gaussianity of control values (p-value saved in \texttt{pvalue.shapiro} column). Significant subset at $\alpha$=\Sexpr{alpha} is saved in \texttt{./output\_files/annotation\_ratio\_compare\_...\_alpha...\_zoom.csv} (';' columns separated) for control and treated samples only. \textcolor{red}{Note that when there are >1 plates within the annotation, a single test is performed by pulling all the samples (\texttt{cell.line} column should match between tests to be consistent).}


<<data-processing-settings, results = hide, echo = F>>=
##### To create flowset and to add informations contained in the annotation as phenoData
fset.raw <- read.flowSet(files = paste("../../data/", annotation$date, "/", annotation$file, sep = ""), transformation = F, alter.names = T)
pData(fset.raw) <- cbind(pData(fset.raw), annotation)

##### Init nb of events 
nb.events.raw <- fsApply(fset.raw, function(x) dim(x)[1], use.exprs = T)

##### Channels for GFP-RFP ratios
channels.all <- channels$fcs.column; marker.all <- channels$channels
channels.per.sample <- annotation$channels
channels.ratio <- sapply(c("GFP", "RFP"), function(x) channels[marker.all == x, ]$fcs.column)
at.least.one.DAPI.stained <- length(which(annotation$dapi == T))>0
nb.channels <- dim(channels)[1]; nb.samples <- dim(annotation)[1]
files.labelled <- list(setdiff(sapply(seq_len(nb.samples), function(y) {x <- channels.per.sample[y]; ifelse(length(grep("RFP", x))>0 & length(grep("GFP", x))>0, annotation$file[y], "None")}), "None"))
files.labelled <- c(files.labelled, list(files.labelled[[1]])); names <- c("ratio.RFP.GFP", "log2.ratio")
for (i in seq_along(marker.all)) {
	files.tmp <- setdiff(sapply(seq_len(nb.samples), function(y) {x <- channels.per.sample[y]; ifelse(length(grep(marker.all[i], x))>0, annotation$file[y], "None")}), "None")
	files.labelled <- c(files.labelled, list(files.tmp, files.tmp))
	names <- c(names, channels.all[i], paste("log10.", strsplit(channels.all[i], ".", fixed = T)[[1]][1], sep = ""))
}
names(files.labelled) <- names

##### Look for extreme values in labelled samples
max.val <- apply(fsApply(fset.raw, each_col, max)[, c("FSC.W", "FSC.A", "SSC.A", rep(channels.all, nb.channels))], 2, function(x) max(x))
min.val <- apply(fsApply(fset.raw, each_col, min)[, c("FSC.W", "FSC.A", "SSC.A", rep(channels.all, nb.channels))], 2, function(x) min(x))
limits.extreme.channels <- rbind(min.val, max.val)
@


<<data-processing, results = hide, echo = F>>=
##### To create gates for saturated events
rectSat <- rectangleGate(filterId = "rectSat", FSC.A = c(min.val["FSC.A"]+1, max.val["FSC.A"]-1), SSC.A = c(min.val["SSC.A"]+1, max.val["SSC.A"]-1)) #rectangleGates are inclusive, that means that events on the boundaries are considered to be in the gate.

##### To create combined gates for each file
for (i in seq_len(nb.channels)) {
	eval(parse(text = paste("rectSat", marker.all[i], " <- rectangleGate(filterId = \"rectSat", marker.all[i], "\", ", channels.all[i], " = c(", min.val[channels.all[i]]+1, ", ", max.val[channels.all[i]]-1, "))", sep = "")))
}
gates <- sapply(seq_along(channels.per.sample), function(y) {x = channels.per.sample[[y]]; eval(parse(text = ifelse(x=="None", "rectSat", paste("rectSat*", paste("rectSat",strsplit(x,",")[[1]], sep = "", collapse = "*"), sep = ""))))})
names(gates) <- sampleNames(fset.raw)

##### To subset according to saturated gates
filt.unsat <- filter(fset.raw, gates)
tfset.unsat <- Subset(fset.raw, filt.unsat)

nb.events.unsat <- fsApply(tfset.unsat, function(x) dim(x)[1], use.exprs = T)
perc.unsat <- 100*nb.events.unsat/nb.events.raw
@


<<check-point-signals, results = hide, echo = F>>=
##### Check for signal over position on plate
mean.signal.plate <- MeanSignalsPlates(annotation, tfset.unsat) 
PlotMeanSignalsPlates(annotation, "./plots/mean_signal_over_plate", mean.signal.plate) 
@


<<gating, results = hide, echo = F>>=
##### Debris removal
DebrisGateNorm <- norm2Filter("FSC.A", "SSC.A", filterId = "Debris.gate.norm", scale=2)
filt.debris <- filter(tfset.unsat, DebrisGateNorm)
tfset.unsat.debris <- Subset(tfset.unsat, filt.debris)
nb.events.unsat.debris <- fsApply(tfset.unsat.debris, function(x) dim(x)[1], use.exprs = T)
perc.debris <- 100*nb.events.unsat.debris/nb.events.unsat
pdf("./plots/SSCA_FSCA_gating_debris.pdf", paper = "a4")
xyplot(`SSC.A` ~ `FSC.A` | file, data = tfset.unsat, filter = filt.debris, names = T, smooth = T, stat = T, pos = 0.75, abs = T, outline = T, par.settings = list(gate = list(col = "red"), gate.text = list(col = "darkred", cex = 0.7)), par.strip.text = list(cex = 0.4, lines = 1))
dev.off()

##### Doublet removal
DoubletGateNorm <- norm2Filter("FSC.A", "FSC.W", filterId = "Doublet.gate.norm", scale=2)
filt.db <- filter(tfset.unsat.debris, DoubletGateNorm)
tfset.unsat.debris.db <- Subset(tfset.unsat.debris, filt.db)
nb.events.unsat.db <- fsApply(tfset.unsat.debris.db, function(x) dim(x)[1], use.exprs = T)
perc.db <- 100*nb.events.unsat.db/nb.events.unsat.debris
pdf("./plots/FSCW_FSCA_gating_doublet.pdf", paper = "a4")
xyplot(`FSC.W` ~ `FSC.A` | file, data = tfset.unsat.debris,  ylim = c(limits.extreme.channels["min.val", "FSC.W"], limits.extreme.channels["max.val", "FSC.W"] ), filter = filt.db, names = T, smooth = T, stat = T, pos = 0.75, abs = T, outline = T, par.settings = list(gate = list(col = "red"), gate.text = list(col = "darkred", cex = 0.7)), par.strip.text = list(cex = 0.4, lines = 1))
dev.off()

##### Channels after gates 
##### To compute the GFP/RFP ratio 
tfset.unsat.debris.db <- fsApply(tfset.unsat.debris.db, FUN = function(fr, ch, chan, files.ratio){ 
mat <- exprs(fr)[, unique(c(chan, ch))]; n <- dim(mat)[1]; f <- keyword(fr, "GUID")$GUID; lbl <- list(); names <- c();
for (i in seq_along(chan)) {
	names <- c(names, paste("log10.", strsplit(chan[i], ".", fixed = T)[[1]][1], sep = ""))
	lbl <- c(lbl, list(log10(mat[, chan[i]])));
}
if(f %in% files.ratio) {
	ratio <- mat[, ch["RFP"]]/mat[, ch["GFP"]];
	lbl <- c(lbl, list(ratio)); lbl <- c(lbl, list(log2(ratio)));
} else {
	lbl <- c(lbl, list(rep(NA, n))); lbl <- c(lbl, list(rep(NA, n)));
}
names <- c(names, "ratio.RFP.GFP", "log2.ratio");
	cbind2(fr, matrix(do.call(cbind, lbl), ncol = length(names), dimnames = list(NULL, names)))}, 
ch = channels.ratio, chan = channels.all, files.ratio = files.labelled[["ratio.RFP.GFP"]]) #https://github.com/Bioconductor-mirror/flowCore/blob/master/R/flowFrame-accessors.R

PlotChannelDensity(flowset = tfset.unsat.debris.db, annotation.init = annotation, files.labelling = files.labelled, suffix = "_gated", limit = T)

nb.samples <- length(tfset.unsat.debris.db)
@


<<check-point-signals2, results = hide, echo = F>>=
##### Check for signal over position on plate
mean.signal.plate <-MeanSignalsPlates(annotation, tfset.unsat.debris.db) 
PlotMeanSignalsPlates(annotation, "./plots/mean_signal_over_plate_processed", mean.signal.plate) 
@


<<plot-ratio, results = hide, echo = F>>=
##### GFP vs RFP after gating
#autoplot( tfset.unsat.debris.db,channels.ratio[1], channels.ratio[2]) 
mean.ratio <- fsApply(tfset.unsat.debris.db, FUN = function(fr, ch){ 
	dat <- exprs(fr)[, c("ratio.RFP.GFP", ch)]; 
	mean.GFP <- mean(dat[, ch["GFP"]]); mean.RFP <- mean(dat[, ch["RFP"]]);
	y <- dat[, "ratio.RFP.GFP"]; mean.ratio <- NA; mean.log2.ratio <- NA
	if (is.na(y[1]) == F) {
		mean.ratio <- mean(y, na.rm = T); mean.log2.ratio <- mean(log2(y), na.rm = T);
	}
	c(mean.GFP, mean.RFP, mean.ratio, mean.log2.ratio)
}, ch = channels.ratio)

annotation$mean.GFP <- mean.ratio[, 1]; annotation$mean.RFP <- mean.ratio[, 2]; annotation$mean.ratio.RFP.GFP <- mean.ratio[, 3]; annotation$mean.log2.ratio <- mean.ratio[, 4]
dapi.channel <- channels[which(channels$channels == "DAPI"), ]$fcs.column
ind <- files.labelled[["ratio.RFP.GFP"]]
lim.max.ratio <- mean(fsApply(tfset.unsat.debris.db[ind], FUN = function(fr){ dat <- exprs(fr)[, "ratio.RFP.GFP"]; max(dat)}))
lim.max.log.ratio <- mean(fsApply(tfset.unsat.debris.db[ind], FUN = function(fr){ dat <- exprs(fr)[, "log2.ratio"]; max(dat)}))
lim.min.log.ratio <- mean(fsApply(tfset.unsat.debris.db[ind], FUN = function(fr){ dat <- exprs(fr)[, "log2.ratio"]; min(dat)}))

ScatterPlotHBin(flowset = tfset.unsat.debris.db[ind], xname = paste("log10.", strsplit(channels.ratio["GFP"], ".", fixed = T)[[1]][1], sep = ""), yname = paste("log10.", strsplit(channels.ratio["RFP"], ".", fixed = T)[[1]][1], sep = ""), ylower = NA, yhigher = NA, title = "./plots/log_ratio2D_gated.pdf", col.by.DAPI = F) 
ScatterPlotHBin(flowset = tfset.unsat.debris.db[ind], xname = channels.ratio["GFP"], yname = channels.ratio["RFP"], ylower = NA, yhigher = NA, title = "./plots/ratio2D_gated.pdf", col.by.DAPI = F) 

ScatterPlotHBin(flowset = tfset.unsat.debris.db[ind], xname = "FSC.A", yname = "log2.ratio", ylower = lim.min.log.ratio, yhigher = lim.max.log.ratio, title = "./plots/log2.ratio_vs_FSCA_gated.pdf", col.by.DAPI = F) 
ScatterPlotHBin(flowset = tfset.unsat.debris.db[ind], xname = "SSC.A", yname = "log2.ratio", ylower = lim.min.log.ratio, yhigher = lim.max.log.ratio, title = "./plots/log2.ratio_vs_SSCA_gated.pdf", col.by.DAPI = F) 

ScatterPlotHBin(flowset = tfset.unsat.debris.db[ind], xname = "FSC.A", yname = "log2.ratio", ylower = lim.min.log.ratio, yhigher = lim.max.log.ratio, title = "./plots/log2.ratio_vs_FSCADAPI_gated.pdf", col.by.DAPI = T) 
ScatterPlotHBin(flowset = tfset.unsat.debris.db[ind], xname = "SSC.A", yname = "log2.ratio", ylower = lim.min.log.ratio, yhigher = lim.max.log.ratio, title = "./plots/log2.ratio_vs_SSCADAPI_gated.pdf", col.by.DAPI = T) 

ind <- intersect(files.labelled[["ratio.RFP.GFP"]], annotation$file[which(annotation$dapi == T)])
ScatterPlotHBin(flowset = tfset.unsat.debris.db[ind], xname = dapi.channel, yname = "log2.ratio", ylower = lim.min.log.ratio, yhigher = lim.max.log.ratio, title = "./plots/log2.ratio_vs_DAPI_gated.pdf", col.by.DAPI = F) 
@


<<correct-signal, echo = F>>=
##### Plot before and after normalization heatmap of ratio
mat.value <- mat.value.template
for (j in seq_along(unique(annotation$plate))) {
	plate <- unique(annotation$plate)[j]
	signal <- mean.signal.plate[[as.character(plate)]]$log2.ratio
	index <- t(sapply(rownames(signal), function(x) {tmp <- annotation[which(annotation$file == x & annotation$plate == plate), ]$code.well; c(substr(tmp, 0,1), substr(tmp,2, 3))}))
	for (x in 1:dim(index)[1]){
		mat.value[index[x,1], index[x,2]] <- unname(signal[x,1])
	}
	pdf(paste("./plots/mean.log2.ratio_over_plate", j, "_processed.pdf", sep = ""), width = 11, height = 7)
	heatmap.2(mat.value, main = paste("Plate ", plate, "\nUnnormalized mean log2.ratio on processed data", sep = ""), dendrogram = "none", trace = "none", density.info = "none", symm = F, Rowv=FALSE, Colv=FALSE)
	dev.off()
	
	pdf(paste("./plots/mean.log2.ratio_over_plate", j, "_normalized_col_processed.pdf", sep = ""), width = 11, height = 7)
	mat.value.z.col <- scale(mat.value) # equivalent to apply(mat.value, 2, function(x) (x-mean(x))/sd(x))
	heatmap.2(mat.value.z.col, main = paste("Plate ", plate, "\nNormalized-by-COLUMN z-value mean log2.ratio\non processed data - DONE", sep = ""), dendrogram = "none", trace = "none", density.info = "none", symm = F, Rowv=FALSE, Colv=FALSE)
	dev.off()

	pdf(paste("./plots/mean.log2.ratio_over_plate", j, "_normalized_row_processed.pdf", sep = ""), width = 11, height = 7)
	mat.value.z.row <- t(apply(mat.value, 1, function(x) (x-mean(x, na.rm = T))/sd(x, na.rm = T)))
	heatmap.2(mat.value.z.row, main = paste("Plate ", plate, "\nNormalized-by-ROW z-value mean log2.ratio\non processed data", sep = ""), dendrogram = "none", trace = "none", density.info = "none", symm = F, Rowv=FALSE, Colv=FALSE)
	dev.off()

	annotation$norm.column.mean.log2.ratio <- NA
	for (i in 1:dim(mat.value.z.col)[1]) {
		for (k in 1:dim(mat.value.z.col)[2]) {
			tmp.code <- paste(rownames(mat.value.z.col)[i], colnames(mat.value.z.col)[k], sep = "")
			annotation$norm.column.mean.log2.ratio[which(annotation$plate == plate & annotation$code.well == tmp.code)] <- mat.value.z.col[i, k]
		}
	}
}
@


<<test-ratio, results = hide, echo = F>>=
##### Make statistical test on ratio
# Files of control samples 
index.control <- which(annotation$file %in% ind  &  annotation$dapi == T  &  annotation$drug == "None" &  annotation$cell.line == compare)
control <- annotation[index.control, ]$file
# File of treated samples
index.drug <- which(annotation$file %in% ind  &  annotation$dapi == T  &  annotation$drug != "None" &  annotation$cell.line == compare)
drug <- annotation[index.drug, c("file", "time")]; 
drug$time <- as.factor(drug$time)

annotation$drug.assessment <- NA; 
annotation$alpha <- NA; 
annotation$pvalue <- NA; 
annotation$pvalue.shapiro <- NA;

annotation$drug.assessment[c(index.control, index.drug)] <- compare; 
annotation$alpha[c(index.control, index.drug)] <- alpha; 
annotation$pvalue[index.control] <- "control"; 

pdf("./plots/control_vs_treated_norm.column.mean.log2.ratio.pdf", paper = "a4")
ind.test.control <- which(annotation$file %in% control); control.ratio <- annotation[ind.test.control, "norm.column.mean.log2.ratio"]
pshapiro <- shapiro.test(control.ratio)$p.value
annotation$pvalue.shapiro[index.control] <- pshapiro
ind.test.drug <- which(annotation$file %in% drug$file); drug.ratio <- annotation[ind.test.drug, c("norm.column.mean.log2.ratio", "file")]
den.control.ratio <- density(control.ratio)
m <- mean(control.ratio); se <- sd(control.ratio)/sqrt(length(control.ratio))
z <- (drug.ratio[, "norm.column.mean.log2.ratio"] - m)/se; pz <- 2*pnorm(-abs(z))
annotation[ind.test.drug, "pvalue"] <- pz
ind.signif <- which(pz<=alpha)
xlim <- c(0.97*min(c(drug.ratio[, "norm.column.mean.log2.ratio"], control.ratio)), max(c(drug.ratio[, "norm.column.mean.log2.ratio"], control.ratio)))
plot(den.control.ratio$x, den.control.ratio$y/max(den.control.ratio$y), xlim = xlim, main = paste(compare, " - Control vs drug samples:\nnorm.column.mean.log2.ratio", sep = ""), ylab = "density/max(density)", xlab = "norm.column.mean.log2.ratio", type = "l")
points(control.ratio, rep(0, length(control.ratio)))
points(drug.ratio[, "norm.column.mean.log2.ratio"], rep(0, dim(drug.ratio)[1])+0.05, col = "red")
if (length(ind.signif)>0) {
	points(drug.ratio[, "norm.column.mean.log2.ratio"][ind.signif], rep(0, length(ind.signif))+0.1, pch = 19, col = "red")
}
legend("topleft", title =  paste("alpha = ", 100*alpha, "%", sep = ""), c(paste(length(control.ratio), " control samples (p.shapiro=", format(pshapiro, digits=3), ")", sep = ""), paste(dim(drug.ratio)[1], " drug samples", sep = ""), paste(length(ind.signif), " significant drugs - 2-sided Z-test", sep = "")), col = c(1, 2, 2), lty = c(-1, -1, -1), pch = c(1, 1, 19), lwd = c(1, 1, 1), bty = "n")
files.signif <- ""; if (length(ind.signif)>0) {files.signif <- drug.ratio[, "file"][ind.signif]}
dev.off()
@

<<write-files, echo = F>>=
##### Write .txt files 
write.table(annotation, paste("./output_files/annotation_ratio_compare_", compare, "_alpha", alpha, ".csv", sep = ""), sep = ";", row.names = F, col.names = T, quote = F)
what.signif <- which(as.numeric(annotation[ind.test.drug, "pvalue"])<=alpha)
ind.keep <- c()
if(length(what.signif)>0) {
	ind.signif.keep <- ind.test.drug[what.signif]
	ind.signif.keep <- ind.signif.keep[order(as.numeric(annotation[ind.signif.keep, "pvalue"]))]
	ind.keep <- c(ind.keep,ind.signif.keep)
}
ind.keep <- c(ind.keep, ind.test.control)
tmp.only.signif <- annotation[ind.keep, c("date", "file", "plate", "well", "code.well", "cell.line", "drug", "time", "mean.GFP", "mean.RFP", "mean.ratio.RFP.GFP", "mean.log2.ratio", "norm.column.mean.log2.ratio", "pvalue", "pvalue.shapiro")]
write.table(tmp.only.signif, paste("./output_files/annotation_ratio_compare_", compare, "_alpha", alpha, "_zoom.csv", sep = ""), sep = ";", row.names = F, col.names = T, quote = F)

end.files <- sampleNames(tfset.unsat.debris.db)
for (i in end.files) {
	write.table( as.data.frame(exprs(tfset.unsat.debris.db[[i]]))[, c("FSC.A", "SSC.A", "FSC.W", channels.all, "ratio.RFP.GFP", "log2.ratio")], paste("./output_files/processed_", i, ".csv", sep = ""), col.names = T, row.names = F, quote = F, sep = ";")
}

##### Follow up nb of events
nb <- cbind(nb.events.raw, nb.events.unsat, perc.unsat, nb.events.unsat.debris, perc.debris, nb.events.unsat.db, perc.db, 100*nb.events.unsat.db/nb.events.raw)
colnames(nb) <- c("raw", "unsat", "perc.from.raw", "first.gating", "perc.from.unsat", "final", "perc.from.first.gating", "perc.from.raw")
nb <- as.data.frame(nb); files <- rownames(nb)
write.table(nb, "./output_files/nb_events.csv", col.names = T, row.names = F, quote = F, sep = ";")
@


% ------------------------------------
\subsection{To remove saturated events}

\textbf{Table of saturation limits for the used channels}:

<<limits, echo = F, results = tex>>=
look.too.saturated <- which(nb$perc.from.raw <= 75)
look.too.much.saturated <- "None"
if (length(look.too.saturated)>0) {
	look.too.much.saturated <- paste(files[look.too.saturated], "(", round(nb$perc.from.raw[look.too.saturated], 1), "\\\\%)", collapse = " / ", sep = "")
}
print(xtable(limits.extreme.channels), hline.after = 0, floating = FALSE, include.rownames = TRUE, include.colnames = TRUE, scalebox = 0.9)
@

 \\
 \\

\textbf{Samples with >25\% of saturated events - sample (\% of kept events):}\\
\Sexpr{look.too.much.saturated}.


% ---------------------------
\subsection{Signal over plate}

First on \textbf{raw} and then \textbf{processed} data:\\
\setkeys{Gin}{width = 0.98\textwidth}
\includegraphics{{./plots/mean_signal_over_plate1}.pdf}\\

\setkeys{Gin}{width = 0.98\textwidth}
\includegraphics{{./plots/mean_signal_over_plate_processed1}.pdf}


% -----------------
\subsection{Gating}

<<gating, echo = F, results = tex>>=
look.too.gating1 <- which(nb$perc.from.unsat <= 60)
look.too.much.gating1 <- "None"
if (length(look.too.gating1)>0) {
	look.too.much.gating1 <- paste(files[look.too.gating1], "(", round(nb$perc.from.unsat[look.too.gating1], 1), "\\\\%)", collapse = " / ", sep = "")
}
look.too.gating2 <- which(nb$perc.from.first.gating <= 75)
look.too.much.gating2 <- "None"
if (length(look.too.gating2)>0) {
	look.too.much.gating2 <- paste(files[look.too.gating2], "(", round(nb$perc.from.first.gating[look.too.gating2], 1), "\\\\%)", collapse = " / ", sep = "")
}
@

\setkeys{Gin}{width = 0.98\textwidth}
\textbf{1st gating} to remove debris (SSC.A-FSC.A plane): \\
\includegraphics{{./plots/SSCA_FSCA_gating_debris}.pdf}\\
\textbf{Samples with >40\% of debris - sample (\% of kept events):}\\
\Sexpr{look.too.much.gating1}.\\

\newpage
\textbf{2nd gating} to remove doublets (FSC.W-FSC.A plane): \\
\includegraphics{{./plots/FSCW_FSCA_gating_doublet}.pdf}\\
\textbf{Samples with >25\% of doublets after removing debris - sample (\% of kept events)}:\\
\Sexpr{look.too.much.gating2}.\\

\newpage
\setkeys{Gin}{width = 0.5\textwidth}
Unsaturating gated channels before and after log10 transformation:\\
\includegraphics{{./plots/B1.A_gated}.pdf}
\includegraphics{{./plots/log10.B1_gated}.pdf}\\
\includegraphics{{./plots/Y1.A_gated}.pdf}
\includegraphics{{./plots/log10.Y1_gated}.pdf}\\
\includegraphics{{./plots/V1.A_gated}.pdf}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Focus on RFP/GFP ratio}

% ---------------------------------------
\subsection{RFP/GFP ratio representation}

Unsaturated gated ratio \textbf{before} and \textbf{after log2} transformation:\\
\setkeys{Gin}{width = 0.49\textwidth}
\includegraphics{{./plots/ratio.RFP.GFP_gated}.pdf}
\includegraphics{{./plots/log2.ratio_gated}.pdf}\\

\newpage
Ratio in 2D: \textbf{after gating and before log10} / \textbf{after log10} for the channels:\\
\includegraphics{{./plots/ratio2D_gated}.pdf}
\includegraphics{{./plots/log_ratio2D_gated}.pdf}\\

Log2 ratio vs SSC.A and FSC.A after gating:\\
\setkeys{Gin}{width = 0.5\textwidth}
\includegraphics{{./plots/log2.ratio_vs_SSCA_gated}.pdf}
\includegraphics{{./plots/log2.ratio_vs_FSCA_gated}.pdf}\\

Log2 ratio vs SSC.A and FSC.A after gating contrasted by DAPI:\\
\setkeys{Gin}{width = 0.5\textwidth}
\includegraphics{{./plots/log2.ratio_vs_SSCADAPI_gated}.pdf}
\includegraphics{{./plots/log2.ratio_vs_FSCADAPI_gated}.pdf}\\

Log2 ratio vs DAPI:\\
\includegraphics{{./plots/log2.ratio_vs_DAPI_gated}.pdf}


% -----------------------------------------------
\subsection{Mean log2 RFP/GFP ratio column-normalization}

\setkeys{Gin}{width = 0.6\textwidth}
Heatmap on processed data \textbf{before} normalization:\\
\includegraphics{{./plots/mean.log2.ratio_over_plate1_processed}.pdf}\\

Heatmap on processed data \textbf{after} \textbf{column}-normalization:\\
\includegraphics{{./plots/mean.log2.ratio_over_plate1_normalized_col_processed}.pdf}\\

Heatmap on processed data \textbf{after} \textbf{row}-normalization:\\
\includegraphics{{./plots/mean.log2.ratio_over_plate1_normalized_row_processed}.pdf}
\setkeys{Gin}{width = 0.5\textwidth}


\newpage
% ----------------------------------
\subsection{Putative drug detection}


<<mean-ratio, results = hide,echo = F>>=
r <- ggplot(annotation[annotation$file %in% files.labelled[[channels.ratio["RFP"]]] == T, ], aes(x = cell.line, y = mean.RFP, col = drug.time)) + ggtitle("mean.RFP")+geom_boxplot(alpha=.2)+ geom_jitter(shape=16, position=position_jitter(width = 0.2))+ geom_rug(col=rgb(.5,0,0,alpha=.3))+ theme(legend.position="top", legend.title=element_text(size=10),plot.title = element_text(face = "bold", size = 15))
g <- ggplot(annotation[annotation$file %in% files.labelled[[channels.ratio["GFP"]]] == T, ], aes(x = cell.line, y = mean.GFP, col = drug.time)) + ggtitle("mean.GFP")+ geom_boxplot(alpha=.2)+ geom_jitter(shape=16, position=position_jitter(width = 0.2))+ geom_rug(col=rgb(.5,0,0,alpha=.3))+ theme(legend.position="top", legend.title=element_text(size=10),plot.title = element_text(face = "bold", size = 15))
rt <- ggplot(annotation[annotation$file %in% files.labelled[["ratio.RFP.GFP"]] == T, ], aes(x = cell.line, y = mean.log2.ratio, col = drug.time)) + ggtitle("mean.log2.ratio")+ geom_boxplot(alpha=.2)+ geom_jitter(shape=16, position=position_jitter(width = 0.2))+ geom_rug(col=rgb(.5,0,0,alpha=.3))+ theme(legend.position="top", legend.title=element_text(size=10),plot.title = element_text(face = "bold", size = 15))
lrt <- ggplot(annotation[annotation$file %in% files.labelled[["ratio.RFP.GFP"]] == T, ], aes(x = cell.line, y = norm.column.mean.log2.ratio, col = drug.time)) + ggtitle("norm.column.mean.log2.ratio")+ geom_boxplot(alpha=.2)+ geom_jitter(shape=16, position=position_jitter(width = 0.2))+ geom_rug(col=rgb(.5,0,0,alpha=.3))+ theme(legend.position="top", legend.title=element_text(size=10),plot.title = element_text(face = "bold", size = 15))

pdf("./plots/ratio_mean_RFP_GFP_gated.pdf", paper = "a4")
grid.arrange(r, g, rt, lrt, ncol = 2)
dev.off()
@


Comparison of mean RFP, mean GFP and ratio accross cell lines after gating and column-normalization:\\
\setkeys{Gin}{width = 0.9\textwidth}
\includegraphics{{./plots/ratio_mean_RFP_GFP_gated}.pdf}

\newpage
Detection of putative drugs by comparing \Sexpr{compare} samples with $\alpha$ = \Sexpr{alpha} :\\
\includegraphics{{./plots/control_vs_treated_norm.column.mean.log2.ratio}.pdf}\\
Putative significative files according to a 2-sided Z-test: \Sexpr{paste(files.signif, collapse = " - ")}.

\setlength{\tabcolsep}{2pt}
%\begin{landscape}
<<mean-ratio-table, results = tex, echo = F>>=
##### Table of nb events 
add.to.row <- list(pos = list(0), command = NULL)
command <- paste0("\\hline\n\\endhead\n","\\hline\n","\\multicolumn{", dim(nb)[2] + 1, "}{l}","{\\footnotesize Continued on next page}\n","\\endfoot\n","\\endlastfoot\n")
add.to.row$command <- command
tmp.only.signif.print <- tmp.only.signif
ind.num.pval <- which(is.na(as.numeric(tmp.only.signif.print$pvalue)) == F)
tmp.only.signif.print[ind.num.pval, ]$pvalue <- format(as.numeric(tmp.only.signif.print[ind.num.pval, ]$pvalue), digits = 3)
tmp.only.signif.print$mean.GFP  <- as.character(round(tmp.only.signif.print$mean.GFP, 3))
tmp.only.signif.print$mean.RFP <- as.character(round(tmp.only.signif.print$mean.RFP, 3))
tmp.only.signif.print$mean.ratio.RFP.GFP <- as.character(round(tmp.only.signif.print$mean.ratio.RFP.GFP, 3))
tmp.only.signif.print$mean.log2.ratio<- as.character(round(tmp.only.signif.print$mean.log2.ratio, 3))
tmp.only.signif.print$norm.column.mean.log2.ratio<- as.character(round(tmp.only.signif.print$norm.column.mean.log2.ratio, 3))

print(xtable(tmp.only.signif.print[, c("date", "file", "plate", "code.well", "cell.line", "drug", "time", "mean.ratio.RFP.GFP", "mean.log2.ratio", "norm.column.mean.log2.ratio", "pvalue")], caption = "(Column-normalized) (log) ratio values for labelled samples and p-values to detect putative drugs"), hline.after = 0, include.rownames = F, size = "\\fontsize{6pt}{6pt}\\selectfont", include.colnames = TRUE, tabular.environment = "longtable", caption.placement = "top", latex.environment = "", table.placement = NULL, add.ro.row = add.to.row, floating.environment = "margintable")#, floating.environment = "sidewaystable")
@
%\end{landscape}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Samples representativity}

<<nb.raw, echo = F, results = hide>>=
look.too.remove <- which(nb$perc.from.raw < 60)
look.too.much.remove <- "None"
if (length(look.too.remove)>0) {
	look.too.much.remove <- paste(files[look.too.remove], "(", round(nb$perc.from.raw[look.too.remove], 1), "\\\\%)", collapse = " / ", sep = "")
}
@

\textbf{Samples with <60\% of events kept from raw data:}\\
\Sexpr{look.too.much.remove}.\\

<<nb-events, results = tex, echo = F>>=
##### Table of nb events 
add.to.row <- list(pos = list(0), command = NULL)
command <- paste0("\\hline\n\\endhead\n","\\hline\n","\\multicolumn{", dim(nb)[2] + 1, "}{l}","{\\footnotesize Continued on next page}\n","\\endfoot\n","\\endlastfoot\n")
add.to.row$command <- command

print(xtable(nb, digits = c(0, 0, 0, 1, 0, 1, 0,1, 1), caption = "Follow up the number of events after each processing step\nNumber and percentage of events after each processing step"), hline.after = 0, floating = FALSE, include.rownames = TRUE, caption.placement="top", size = "\\fontsize{8pt}{8pt}\\selectfont", include.colnames = TRUE, tabular.environment = "longtable", add.ro.row = add.to.row)
@


\end{document}

